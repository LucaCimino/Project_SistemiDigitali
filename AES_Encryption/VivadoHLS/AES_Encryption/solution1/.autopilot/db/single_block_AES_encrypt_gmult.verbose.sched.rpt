

================================================================
== Vivado HLS Report for 'single_block_AES_encrypt_gmult'
================================================================
* Date:           Thu Feb 08 10:03:56 2024

* Version:        2016.2 (Build 1577090 on Thu Jun 02 16:59:10 MDT 2016)
* Project:        AES_Encryption
* Solution:       solution1
* Product family: zynq
* Target device:  xc7z020clg400-1


================================================================
== Performance Estimates
================================================================
+ Timing (ns): 
    * Summary: 
    +--------+-------+----------+------------+
    |  Clock | Target| Estimated| Uncertainty|
    +--------+-------+----------+------------+
    |ap_clk  |  10.00|      4.11|        1.25|
    +--------+-------+----------+------------+

+ Latency (clock cycles): 
    * Summary: 
    +-----+-----+-----+-----+----------+
    |  Latency  |  Interval | Pipeline |
    | min | max | min | max |   Type   |
    +-----+-----+-----+-----+----------+
    |    0|    0|    1|    1| function |
    +-----+-----+-----+-----+----------+

    + Detail: 
        * Instance: 
        N/A

        * Loop: 
        N/A

============================================================
+ Verbose Summary: Synthesis Manager
============================================================
InlineROM: 1
ExposeGlobal: 0
============================================================
+ Verbose Summary: CDFG Model
============================================================
IsTopModel: 0
ResetActiveHigh: 1
IsCombinational: 0
IsDatapathOnly: 0
HasWiredReturn: 1
HasMFsm: 2
HasVarLatency: 0
IsPipeline: 1
IsRtlPipelined: 0
IsInstanceOverlapped: 0
IsDontTouch: 0
HasImplIP: 0
IsGatedGlobalClock: 0

+ Individual pipeline summary: 
  * Pipeline-0: initiation interval (II) = 1, depth = 1


============================================================
+ Verbose Summary: Schedule
============================================================
* Number of FSM states: 1
* Pipeline: 1
  Pipeline-0: II = 1, D = 1, States = { 1 }
* Dataflow Pipeline: 0

* FSM state transitions: 
1 --> 
* FSM state operations: 

 <State 1>: 4.11ns
ST_1: b_read [1/1] 0.00ns
:0  %b_read = call i8 @_ssdm_op_Read.ap_auto.i8(i8 %b)

ST_1: a_read [1/1] 0.00ns
:1  %a_read = call i4 @_ssdm_op_Read.ap_auto.i4(i4 %a)

ST_1: tmp [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:2  %tmp = trunc i8 %b_read to i1

ST_1: tmp_1 [1/1] 0.00ns
:3  %tmp_1 = trunc i4 %a_read to i2

ST_1: tmp_7 [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:4  %tmp_7 = select i1 %tmp, i2 %tmp_1, i2 0

ST_1: tmp_7_cast [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:5  %tmp_7_cast = zext i2 %tmp_7 to i3

ST_1: a_assign [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:6  %a_assign = call i3 @_ssdm_op_BitConcatenate.i3.i2.i1(i2 %tmp_1, i1 false)

ST_1: tmp_2 [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:7  %tmp_2 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %b_read, i32 1)

ST_1: tmp_24_1 [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:8  %tmp_24_1 = select i1 %tmp_2, i3 %a_assign, i3 0

ST_1: tmp_3 [1/1] 0.00ns (grouped into LUT with out node tmp4)
:9  %tmp_3 = shl i4 %a_read, 2

ST_1: tmp_4 [1/1] 0.00ns (grouped into LUT with out node tmp4)
:10  %tmp_4 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %b_read, i32 2)

ST_1: tmp_24_2 [1/1] 0.00ns (grouped into LUT with out node tmp4)
:11  %tmp_24_2 = select i1 %tmp_4, i4 %tmp_3, i4 0

ST_1: tmp_24_2_cast [1/1] 0.00ns (grouped into LUT with out node tmp4)
:12  %tmp_24_2_cast = zext i4 %tmp_24_2 to i5

ST_1: a_assign_7 [1/1] 0.00ns (grouped into LUT with out node tmp4)
:13  %a_assign_7 = call i5 @_ssdm_op_BitConcatenate.i5.i2.i3(i2 %tmp_1, i3 0)

ST_1: tmp_5 [1/1] 0.00ns (grouped into LUT with out node tmp4)
:14  %tmp_5 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %b_read, i32 3)

ST_1: tmp_24_3 [1/1] 0.00ns (grouped into LUT with out node tmp4)
:15  %tmp_24_3 = select i1 %tmp_5, i5 %a_assign_7, i5 0

ST_1: a_assign_3 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:16  %a_assign_3 = call i6 @_ssdm_op_BitConcatenate.i6.i2.i4(i2 %tmp_1, i4 0)

ST_1: tmp_6 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:17  %tmp_6 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %b_read, i32 4)

ST_1: tmp_24_4 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:18  %tmp_24_4 = select i1 %tmp_6, i6 %a_assign_3, i6 0

ST_1: tmp_24_4_cast [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:19  %tmp_24_4_cast = zext i6 %tmp_24_4 to i7

ST_1: a_assign_4 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:20  %a_assign_4 = call i7 @_ssdm_op_BitConcatenate.i7.i2.i5(i2 %tmp_1, i5 0)

ST_1: tmp_8 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:21  %tmp_8 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %b_read, i32 5)

ST_1: tmp_24_5 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:22  %tmp_24_5 = select i1 %tmp_8, i7 %a_assign_4, i7 0

ST_1: a_assign_5 [1/1] 0.00ns (grouped into LUT with out node tmp7)
:23  %a_assign_5 = call i8 @_ssdm_op_BitConcatenate.i8.i2.i6(i2 %tmp_1, i6 0)

ST_1: tmp_9 [1/1] 0.00ns (grouped into LUT with out node tmp7)
:24  %tmp_9 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %b_read, i32 6)

ST_1: tmp_24_6 [1/1] 0.00ns (grouped into LUT with out node tmp7)
:25  %tmp_24_6 = select i1 %tmp_9, i8 %a_assign_5, i8 0

ST_1: tmp_10 [1/1] 0.00ns
:26  %tmp_10 = trunc i4 %a_read to i1

ST_1: a_assign_6 [1/1] 0.00ns
:27  %a_assign_6 = call i8 @_ssdm_op_BitConcatenate.i8.i1.i7(i1 %tmp_10, i7 0)

ST_1: tmp_11 [1/1] 0.00ns (grouped into LUT with out node tmp7)
:28  %tmp_11 = call i1 @_ssdm_op_BitSelect.i1.i4.i32(i4 %a_read, i32 1)

ST_1: a_assign_1_s [1/1] 0.00ns (grouped into LUT with out node tmp7)
:29  %a_assign_1_s = or i8 %a_assign_6, 27

ST_1: a_assign_2_6 [1/1] 0.00ns (grouped into LUT with out node tmp7)
:30  %a_assign_2_6 = select i1 %tmp_11, i8 %a_assign_1_s, i8 %a_assign_6

ST_1: tmp_12 [1/1] 0.00ns (grouped into LUT with out node tmp7)
:31  %tmp_12 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %b_read, i32 7)

ST_1: tmp_24_7 [1/1] 0.00ns (grouped into LUT with out node tmp7)
:32  %tmp_24_7 = select i1 %tmp_12, i8 %a_assign_2_6, i8 0

ST_1: tmp3 [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:33  %tmp3 = xor i3 %tmp_24_1, %tmp_7_cast

ST_1: tmp3_cast [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:34  %tmp3_cast = zext i3 %tmp3 to i5

ST_1: tmp4 [1/1] 1.37ns (out node of the LUT)
:35  %tmp4 = xor i5 %tmp_24_2_cast, %tmp_24_3

ST_1: tmp2 [1/1] 0.00ns (grouped into LUT with out node tmp2_cast)
:36  %tmp2 = xor i5 %tmp4, %tmp3_cast

ST_1: tmp2_cast [1/1] 1.37ns (out node of the LUT)
:37  %tmp2_cast = zext i5 %tmp2 to i8

ST_1: tmp6 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:38  %tmp6 = xor i7 %tmp_24_4_cast, %tmp_24_5

ST_1: tmp6_cast [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:39  %tmp6_cast = zext i7 %tmp6 to i8

ST_1: tmp7 [1/1] 1.37ns (out node of the LUT)
:40  %tmp7 = xor i8 %tmp_24_6, %tmp_24_7

ST_1: tmp5 [1/1] 0.00ns (grouped into LUT with out node p_0_7)
:41  %tmp5 = xor i8 %tmp7, %tmp6_cast

ST_1: p_0_7 [1/1] 1.37ns (out node of the LUT)
:42  %p_0_7 = xor i8 %tmp5, %tmp2_cast

ST_1: stg_45 [1/1] 0.00ns
:43  ret i8 %p_0_7



============================================================
+ Verbose Summary: Timing violations
============================================================
Target clock period: 10ns, clock uncertainty: 1.25ns.

 No timing violations. 


============================================================
+ Verbose Summary: Binding
============================================================
N/A
* FSMD analyzer results:
  - Output states:
 - Input state : 
  - Chain level:
	State 1


============================================================
+ Verbose Summary: Datapath Resource usage 
============================================================
N/A
